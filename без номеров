#include "TFormula.h"
#include "TStack.h"

std::ostream& operator<<(std::ostream& out, const TFormula& form)
{
    out << form.str;
    return out;
}

std::istream& operator>>(std::istream& in, TFormula& form)
{
    const int MAX = 100;
    char buffer[MAX];
    int i = 0;
    char c;
    delete[] form.str;
    while (in.get(c) && c != '\n' && i < MAX - 1) {
        buffer[i] = c;
        i++;
    }
    if (i == MAX - 1) {
        buffer[MAX - 1] = '\0';
    }
    else {
        buffer[i] = '\0';
    }
    if (i > 0) {
        form.str = new char[i + 1];
        for (int j = 0; j <= i; j++) {
            form.str[j] = buffer[j];
        }
    }
    else {
        form.str = nullptr;
    }
    return in;
}

bool isdigit(char c)
{
    bool res = true;
    if ((c != '1') && (c != '2') && (c != '3') && (c != '4') &&
        (c != '5') && (c != '6') && (c != '7') && (c != '8') &&
        (c != '9') && (c != '0')) {
        res = false;
    }
    return res;
}

bool isop(char c)
{
    bool res = false;
    if ((c == '+') || (c == '-') || (c == '*') || (c == '/')) {
        res = true;
    }
    return res;
}

bool isbracket(char c)
{
    bool res = false;
    if ((c == '(') || (c == ')')) {
        res = true;
    }
    return res;
}

bool isletter(char c)
{
    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';
}

int priority(char op)
{
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    if (op == '^') return 3;
    return 0;
}

TFormula::TFormula(char* _str)
{
    size_t len = strlen(_str);
    str = new char[len + 1];
    for (size_t i = 0; i <= len; i++) {
        str[i] = _str[i];
    }
}

TFormula::~TFormula()
{
    delete[] str;
}

TFormula::TFormula(const TFormula& _str)
{
    if (_str.str) {
        size_t len = strlen(_str.str);
        str = new char[len + 1];
        for (size_t i = 0; i <= len; i++) {
            str[i] = _str.str[i];
        }
    }
    else {
        str = nullptr;
    }
}

TFormula TFormula::operator=(const TFormula& _str)
{
    if (this != &_str) {
        delete[] str;

        if (_str.str) {
            size_t len = strlen(_str.str);
            str = new char[len + 1];
            for (size_t i = 0; i < len; i++) {
                str[i] = _str.str[i];
            }
        }
        else {
            str = nullptr;
        }
    }
    return *this;
}

TFormula::TFormula() :str(nullptr) {}

int TFormula::checkbrackets(int arr[], int& n)
{
    n = 0;
    if (!str) return n;
    TDynamicStack<int> stack;
    int len = strlen(str);
    std::cout << "Таблица скобок:" << std::endl;
    std::cout << "Открывающие   Закрывающие" << std::endl;
    int nomer_skobki = 0;
    for (int i = 0; i < len; i++) {
        if (str[i] == '(') {
            nomer_skobki++;
            stack.Push(nomer_skobki); 
        }
        else if (str[i] == ')') {
            nomer_skobki++;
            if (stack.IsEmpty()) {
                arr[n++] = nomer_skobki;
                std::cout << "              " << nomer_skobki << " (нет открывающей)" << std::endl;
            }
            else {
                int open_pos = stack.Pop();
                std::cout << open_pos << "             " << nomer_skobki << std::endl;
            }
        }
    }
    while (!stack.IsEmpty()) {
        int open_pos = stack.Pop();
        arr[n++] = open_pos;
        std::cout << open_pos << "              (нет закрывающей)" << std::endl;
    }
    return n;
}

char* TFormula::Postfix()
{
    int errorPositions[100];
    int errorCount = 0;
    if (checkbrackets(errorPositions, errorCount) != 0) {
        throw 1;
    }
    int len = strlen(str);
    TDynamicStack<char> st(len + 1);
    int maxSize = len * 3 + 1;
    char* result = new char[maxSize];
    int resultIndex = 0;
    bool predetoop = false;
    bool predetooperand = false;
    for (int i = 0; i < len; i++) {
        char c = str[i];
        if (c == ' ') continue;
        if (isdigit(c) || c == '.' || isletter(c)) {
            bool tochka_bila = false;
            bool cifra_bila = false;
            bool bukva_bila = false;
            if (predetooperand) {
                delete[] result;
                throw 8; 
            }

            while (i < len && (isdigit(str[i]) || str[i] == '.' || isletter(str[i]))) {
                if (resultIndex >= maxSize - 1) {
                    delete[] result;
                    throw 5; 
                }
                if (isdigit(str[i])) {
                    cifra_bila = true;
                }
                else if (str[i] == '.') {
                    if (tochka_bila) {
                        delete[] result;
                        throw 2;
                    }
                    tochka_bila = true;
                }
                else if (isletter(str[i])) {
                    bukva_bila = true;
                }
                result[resultIndex++] = str[i++];
            }
            if (!bukva_bila) {
                if (!cifra_bila) {
                    delete[] result;
                    throw 3;
                }
            }
            if (resultIndex >= maxSize - 1) {
                delete[] result;
                throw 5; 
            }
            result[resultIndex++] = ' ';
            i--;
            predetoop = false;
            predetooperand = true;
        }
        else if (isop(c)) {
            if (c == '-' && (i == 0 || str[i - 1] == '(' || isop(str[i - 1]))) {
                result[resultIndex++] = '0';
                result[resultIndex++] = ' ';
                while (!st.IsEmpty() && isop(st.Peek()) &&
                    priority(st.Peek()) >= priority(c)) {
                    if (resultIndex >= maxSize - 2) {
                        delete[] result;
                        throw 5;
                    }
                    result[resultIndex++] = st.Pop();
                    result[resultIndex++] = ' ';
                }
                st.Push(c);
                predetoop = true;
                predetooperand = false;
            }
            else {
                if (predetoop) {
                    delete[] result;
                    throw 6;
                }
                if (!predetooperand) {
                    delete[] result;
                    throw 9;
                }
                while (!st.IsEmpty() && isop(st.Peek()) &&
                    priority(st.Peek()) >= priority(c)) {
                    if (resultIndex >= maxSize - 2) {
                        delete[] result;
                        throw 5;
                    }
                    result[resultIndex++] = st.Pop();
                    result[resultIndex++] = ' ';
                }
                st.Push(c);
                predetoop = true;
                predetooperand = false;
            }
        }
        else if (c == '(') {
            if (predetooperand) {
                delete[] result;
                throw 8;
            }
            st.Push(c);
            predetooperand = false;
        }
        else if (c == ')') {
            if (predetoop) {
                delete[] result;
                throw 10;
            }
            while (!st.IsEmpty() && st.Peek() != '(') {
                if (resultIndex >= maxSize - 2) {
                    delete[] result;
                    throw 5;
                }
                result[resultIndex++] = st.Pop();
                result[resultIndex++] = ' ';
            }
            if (st.IsEmpty()) {
                delete[] result;
                throw 1;
            }
            st.Pop();
            predetooperand = true;
        }
        else {
            delete[] result;
            throw 4;
        }
    }
    if (predetoop) {
        delete[] result;
        throw 11;
    }

    while (!st.IsEmpty()) {
        if (st.Peek() == '(') {
            delete[] result;
            throw 1;
        }
        if (resultIndex >= maxSize - 2) {
            delete[] result;
            throw 5;
        }
        result[resultIndex++] = st.Pop();
        result[resultIndex++] = ' ';
    }

    if (resultIndex > 0) {
        if (result[resultIndex - 1] == ' ') {
            result[resultIndex - 1] = '\0';
        }
        else {
            result[resultIndex] = '\0';
        }
    }
    else {
        result[0] = '\0';
    }

    return result;
}

double TFormula::calculate(int& r)
{
    r = 0;
    char* pf = Postfix();
    std::cout << "Постфиксная форма: " << pf << std::endl;
    for (int j = 0; j < strlen(pf); j++) {
        if (isletter(pf[j])) {
            delete[] pf;
            throw 4;
        }
    }
    TDynamicStack<double> st(strlen(pf) + 1);
    for (int i = 0; i < strlen(pf); i++) {
        if (pf[i] == ' ') continue;

        if (isdigit(pf[i]) || pf[i] == '.') {
            double n = 0;
            double d = 1;
            bool point = false;

            while (i < strlen(pf) && (isdigit(pf[i]) || pf[i] == '.')) {
                if (pf[i] == '.') {
                    point = true;
                }
                else if (!point) {
                    n = n * 10 + (pf[i] - '0');
                }
                else {
                    n = n + (pf[i] - '0') / (d * 10);
                    d = d * 10;
                }
                i++;
            }
            i--;
            st.Push(n);
        }
        else if (isop(pf[i])) {
            if (st.size() < 2) {
                delete[] pf;
                throw 12;
            }
            double b = st.Pop();
            double a = st.Pop();
            double res;

            if (pf[i] == '+') res = a + b;
            else if (pf[i] == '-') res = a - b;
            else if (pf[i] == '*') res = a * b;
            else if (pf[i] == '/') {
                if (b == 0) {
                    delete[] pf;
                    throw 7;
                }
                res = a / b;
            }
            st.Push(res);
        }
    }
    if (st.size() != 1) {
        delete[] pf;
        throw 13;
    }
    double res = st.Pop();
    if (fabs(res) < 1e-9) {
        res = 0;
    }
    delete[] pf;
    return res;
}
